<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CMR Client</title>
  <style>
    :root {
      --bg: #eff4f1;
      --panel: #ffffff;
      --ink: #1f2c24;
      --muted: #5f7465;
      --line: #c8d7cd;
      --accent: #1d7e53;
      --accent-soft: #e1f3e9;
      --warn: #946109;
      --warn-soft: #f8ecd1;
      --bad: #8e2b2f;
      --bad-soft: #f8e1e2;
      --good: #1e6f42;
      --good-soft: #e2f3e9;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--ink); font-family: Inter, system-ui, sans-serif; }
    .shell { width: min(1240px, 100% - 24px); margin: 14px auto 24px auto; display: grid; gap: 10px; }
    .card { background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 12px; }
    .head { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    h1 { margin: 0; font-size: 30px; }
    .subtitle { margin-top: 4px; color: var(--muted); font-size: 14px; }
    .tiny { color: var(--muted); font-size: 12px; }

    .tabs { display: flex; flex-wrap: wrap; gap: 8px; }
    .tab { border: 1px solid var(--line); border-radius: 999px; padding: 8px 12px; background: #f0f5f2; cursor: pointer; font-weight: 700; }
    .tab.active { background: var(--accent-soft); border-color: #95c9ab; color: #0f5d3d; }

    .view { display: none; }
    .view.active { display: block; }

    .grid { display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); gap: 10px; }
    .span-12 { grid-column: span 12; }
    .span-8 { grid-column: span 8; }
    .span-6 { grid-column: span 6; }
    .span-4 { grid-column: span 4; }
    .span-3 { grid-column: span 3; }
    @media (max-width: 980px) { .span-8, .span-6, .span-4, .span-3 { grid-column: span 12; } }

    label { display: block; margin-bottom: 4px; color: var(--muted); font-size: 12px; font-weight: 700; text-transform: uppercase; }
    input, textarea, select, button { width: 100%; border: 1px solid var(--line); border-radius: 9px; padding: 8px 10px; font: inherit; }
    textarea { resize: vertical; min-height: 120px; }
    button { width: auto; cursor: pointer; background: #eef5f1; font-weight: 700; }
    button.primary { background: var(--accent-soft); border-color: #95c9ab; color: #0f5d3d; }
    button.warn { background: var(--warn-soft); border-color: #d8b46f; color: #734a00; }

    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .status { padding: 8px 10px; border-radius: 9px; border: 1px solid var(--line); background: #f5faf7; font-size: 13px; }
    .status.good { color: var(--good); background: var(--good-soft); border-color: #9bc9ad; }
    .status.bad { color: var(--bad); background: var(--bad-soft); border-color: #daabad; }

    .list { display: grid; gap: 8px; }
    .item { border: 1px solid var(--line); border-radius: 10px; padding: 10px; background: #fbfdfb; }
    .item h3 { margin: 0 0 4px 0; font-size: 15px; }
    .item .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; }
    .badge { display: inline-block; border: 1px solid #bcd0c2; border-radius: 999px; padding: 2px 8px; font-size: 11px; background: #f0f6f2; margin-right: 4px; }
    .snippet { white-space: pre-wrap; word-break: break-word; }

    details { border: 1px solid var(--line); border-radius: 9px; padding: 8px; background: #f9fcfa; }
    details > summary { cursor: pointer; font-weight: 700; }

    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #e0ebe4; text-align: left; padding: 7px; font-size: 13px; }
    th { background: #edf5ef; }
  </style>
</head>
<body>
  <div class="shell">
    <section class="card head">
      <div>
        <h1>CMR Client</h1>
        <div class="subtitle">Content-searchable message pool client (post + retrieve related messages).</div>
      </div>
      <div class="row" id="runtimeStatus"></div>
    </section>

    <section class="card tabs" id="tabs">
      <button class="tab active" data-view="home">Post + Search</button>
      <button class="tab" data-view="results">Results</button>
      <button class="tab" data-view="thread">Thread</button>
      <button class="tab" data-view="identity">Identity & Keys</button>
      <button class="tab" data-view="inbox">Inbox</button>
    </section>

    <section class="card view active" id="view-home">
      <div class="grid">
        <div class="span-12">
          <label for="mainBox">Ask / post anything</label>
          <textarea id="mainBox" placeholder="Ask a question, post a fact, or continue a conversation..."></textarea>
        </div>
        <div class="span-4">
          <label for="identitySelect">Identity (first header line)</label>
          <select id="identitySelect"></select>
          <div class="tiny">Identity is the address written as message sender.</div>
        </div>
        <div class="span-4">
          <label for="destination">Destination (optional)</label>
          <input id="destination" placeholder="http://peer.example/cmr" />
          <div class="tiny">Leave blank for ambient routing seed behavior.</div>
        </div>
        <div class="span-4">
          <label for="extraDest">Extra destinations</label>
          <input id="extraDest" placeholder="http://a/cmr, http://b/cmr" />
        </div>
        <div class="span-6">
          <label for="sources">Include sources (one URL per line)</label>
          <textarea id="sources" placeholder="https://source1\nhttps://source2"></textarea>
        </div>
        <div class="span-6">
          <label for="attachments">Attach files (bytes stored as base64 in message envelope)</label>
          <input id="attachments" type="file" multiple />
          <div class="tiny" id="attachMeta"></div>
        </div>
        <div class="span-12 row">
          <label><input id="sign" type="checkbox" style="width:auto"> Sign message (when pairwise key exists)</label>
          <label><input id="postPublic" type="checkbox" checked style="width:auto"> Post publicly</label>
          <button class="primary" id="postBtn">Post to message pool</button>
          <button id="searchBtn">Search pool only</button>
        </div>
      </div>
      <div id="homeStatus" class="status" style="margin-top:10px;">Ready.</div>
    </section>

    <section class="card view" id="view-results">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <strong>Related messages</strong>
        <span class="tiny">Posting returns related messages; search lists matching pool entries.</span>
      </div>
      <div id="resultList" class="list" style="margin-top:8px;"></div>
      <details id="whyDrawer" style="margin-top:10px;">
        <summary>Why did I see this?</summary>
        <div id="whyBody" class="tiny" style="margin-top:6px;"></div>
      </details>
    </section>

    <section class="card view" id="view-thread">
      <div class="grid">
        <div class="span-12"><strong>Conversation as message chain</strong></div>
        <div class="span-8">
          <div id="threadMessages" class="list"></div>
        </div>
        <div class="span-4">
          <label for="threadReply">Post reply</label>
          <textarea id="threadReply" placeholder="Write follow-up message..."></textarea>
          <button class="primary" id="threadReplyBtn" style="margin-top:8px;">Post reply</button>
          <div class="tiny" style="margin-top:8px;">Replies are new messages. No edits/deletes; post updates as new messages.</div>
        </div>
      </div>
    </section>

    <section class="card view" id="view-identity">
      <div class="grid">
        <div class="span-6">
          <strong>My addresses</strong>
          <div class="tiny">Stored in browser for this client UI.</div>
          <div class="row" style="margin-top:8px;">
            <input id="newIdentity" placeholder="https://my-client.example/cmr" />
            <button id="addIdentity">Add identity</button>
          </div>
          <div id="identityTable" style="margin-top:8px;"></div>
        </div>
        <div class="span-6">
          <strong>Trusted peers / shared key preferences</strong>
          <div class="tiny">CMR key material is pairwise; this UI stores signing preferences per peer locally.</div>
          <div class="row" style="margin-top:8px;">
            <input id="newPeer" placeholder="http://peer.example/cmr" />
            <button id="addPeer">Track peer</button>
          </div>
          <div id="peerTable" style="margin-top:8px;"></div>
        </div>
      </div>
    </section>

    <section class="card view" id="view-inbox">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <strong>Inbox (messages routed back to this router)</strong>
        <button id="refreshInbox">Refresh</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <input id="inboxFilter" placeholder="Filter inbox by sender/body" />
      </div>
      <div id="inboxList" class="list" style="margin-top:8px;"></div>
    </section>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const storeKey = 'cmr_client_state_v2';
    const state = {
      localAddress: '',
      identities: [],
      selectedIdentity: '',
      peers: [],
      messageHistory: [],
      lastCompose: null,
      lastSearch: null,
      inbox: [],
      attachments: [],
    };

    function loadState() {
      try {
        const parsed = JSON.parse(localStorage.getItem(storeKey) || '{}');
        if (Array.isArray(parsed.identities)) state.identities = parsed.identities;
        if (typeof parsed.selectedIdentity === 'string') state.selectedIdentity = parsed.selectedIdentity;
        if (Array.isArray(parsed.peers)) state.peers = parsed.peers;
        if (Array.isArray(parsed.messageHistory)) state.messageHistory = parsed.messageHistory;
      } catch (_) {}
    }

    function saveState() {
      localStorage.setItem(storeKey, JSON.stringify({
        identities: state.identities,
        selectedIdentity: state.selectedIdentity,
        peers: state.peers,
        messageHistory: state.messageHistory.slice(-200),
      }));
    }

    async function api(path, options = {}) {
      const response = await fetch(resolveApiPath(path), options);
      const json = await response.json().catch(() => null);
      if (!response.ok || !json?.ok) {
        throw new Error(json?.error?.message || `HTTP ${response.status}`);
      }
      return json.data;
    }

    function resolveApiPath(path) {
      const base = window.location.pathname.replace(/\/+$/, '') || '';
      if (/^https?:\/\//i.test(path)) return path;
      if (!path.startsWith('/')) {
        path = `/${path}`;
      }
      if (path.startsWith('/api/')) {
        return `${base}${path}`;
      }
      if (path.startsWith('./api/')) {
        return `${base}${path.slice(1)}`;
      }
      return `${base}${path}`;
    }

    function setHomeStatus(text, kind = 'ok') {
      const node = $('homeStatus');
      node.textContent = text;
      node.className = `status ${kind === 'error' ? 'bad' : 'good'}`;
    }

    function parseCsv(raw) {
      return raw.split(',').map(v => v.trim()).filter(Boolean);
    }

    function parseSources(raw) {
      return raw
        .split('\n')
        .map(v => v.trim())
        .filter(Boolean);
    }

    function inferBadges(sender) {
      const badges = [];
      if (sender.startsWith('http://') || sender.startsWith('https://')) badges.push('human/service');
      if (sender.includes('calc') || sender.includes('api') || sender.includes('service')) badges.push('expert service');
      if (!badges.length) badges.push('peer');
      return badges;
    }

    function renderRuntimePills(data) {
      const row = $('runtimeStatus');
      row.innerHTML = '';
      const add = (text, cls = '') => {
        const span = document.createElement('span');
        span.className = `status ${cls}`;
        span.textContent = text;
        row.appendChild(span);
      };
      add(`Local: ${data.local_address || 'unknown'}`);
      add(`Ingest: ${data.ingest_enabled ? 'on' : 'off'}`, data.ingest_enabled ? 'good' : 'bad');
      add(`Transport: ${data.transport_enabled ? 'on' : 'off'}`, data.transport_enabled ? 'good' : 'bad');
    }

    function renderIdentitySelect() {
      const select = $('identitySelect');
      select.innerHTML = '';
      const identities = Array.from(new Set([state.localAddress, ...state.identities].filter(Boolean)));
      if (!identities.length) identities.push('');
      for (const identity of identities) {
        const option = document.createElement('option');
        option.value = identity;
        option.textContent = identity || '(router local identity)';
        select.appendChild(option);
      }
      if (!state.selectedIdentity || !identities.includes(state.selectedIdentity)) {
        state.selectedIdentity = identities[0] || '';
      }
      select.value = state.selectedIdentity;
      saveState();
    }

    function renderIdentityTable() {
      const identities = Array.from(new Set([state.localAddress, ...state.identities].filter(Boolean)));
      $('identityTable').innerHTML = `
        <table>
          <thead><tr><th>Address</th><th>Active</th><th>Action</th></tr></thead>
          <tbody>
            ${identities.map((id) => `
              <tr>
                <td>${id}</td>
                <td>${state.selectedIdentity === id ? 'yes' : 'no'}</td>
                <td>
                  <button data-act="use-id" data-id="${encodeURIComponent(id)}">Use</button>
                  ${id === state.localAddress ? '' : `<button data-act="del-id" data-id="${encodeURIComponent(id)}">Remove</button>`}
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;
    }

    function renderPeerTable() {
      $('peerTable').innerHTML = `
        <table>
          <thead><tr><th>Peer</th><th>Always sign</th><th>Action</th></tr></thead>
          <tbody>
            ${state.peers.map((peer) => `
              <tr>
                <td>${peer.address}</td>
                <td><input type="checkbox" data-act="toggle-peer" data-peer="${encodeURIComponent(peer.address)}" ${peer.alwaysSign ? 'checked' : ''} /></td>
                <td><button data-act="del-peer" data-peer="${encodeURIComponent(peer.address)}">Remove</button></td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;
    }

    function renderResults() {
      const container = $('resultList');
      const compose = state.lastCompose;
      const search = state.lastSearch;
      if (!compose && !search) {
        container.innerHTML = '<div class="tiny">No results yet. Post or search from Home.</div>';
        $('whyBody').textContent = 'No routing details yet.';
        return;
      }

      if (search) {
        container.innerHTML = search.entries.map((entry, idx) => {
          const score = Math.max(0.01, (1 - (idx / Math.max(search.entries.length, 1)))).toFixed(2);
          const badges = inferBadges(entry.sender).map((b) => `<span class="badge">${b}</span>`).join('');
          return `
            <div class="item" data-thread="cache-${idx}">
              <h3>${entry.body_preview || '(empty)'}</h3>
              <div class="meta">Similarity: ${score} · ${entry.sender} · ${entry.timestamp}</div>
              <div>${badges}</div>
              <div class="snippet">${entry.body_preview || ''}</div>
            </div>
          `;
        }).join('');
      } else {
        const matches = compose.returned_matches || [];
        container.innerHTML = matches.length ? matches.map((entry, idx) => {
          const score = Math.max(0.01, (1 - (idx / Math.max(matches.length, 1)))).toFixed(2);
          const badges = [
            ...inferBadges(entry.sender),
            compose.signed ? 'signed' : 'unsigned',
          ].map((b) => `<span class="badge">${b}</span>`).join('');
          return `
            <div class="item" data-thread="match-${idx}">
              <h3>${entry.body_preview || '(empty)'}</h3>
              <div class="meta">Match strength: ${score} · ${entry.sender} · bytes ${entry.encoded_size}</div>
              <div>${badges}</div>
              <div class="snippet">${entry.body_text || entry.body_preview || ''}</div>
            </div>
          `;
        }).join('') : '<div class="tiny">No related messages returned for this post.</div>';

        const event = compose.local_event;
        const forwardPath = (event?.forwards || []).map(f => `${f.destination} (${f.reason})`).join(' -> ');
        $('whyBody').innerHTML = `
          Matched against: ${event?.matched_count ?? 0} cached messages.<br>
          Routed via: ${forwardPath || 'no outbound forwards (local-only or ambient none)'}<br>
          Drop reason: ${event?.drop_reason || 'none'}
        `;
      }
    }

    function renderThread() {
      const container = $('threadMessages');
      if (!state.messageHistory.length) {
        container.innerHTML = '<div class="tiny">No thread history yet. Post a message first.</div>';
        return;
      }
      container.innerHTML = state.messageHistory.slice().reverse().map((item) => `
        <div class="item">
          <h3>${item.kind === 'outbound' ? 'Posted message' : 'Received/matched message'}</h3>
          <div class="meta">${item.sender || 'client'} · ${item.ts || new Date().toISOString()}</div>
          <div class="snippet">${item.body || ''}</div>
          <details style="margin-top:6px;">
            <summary>Route / provenance</summary>
            <div class="tiny" style="margin-top:6px; white-space: pre-wrap;">${item.route || 'No route metadata available.'}</div>
          </details>
        </div>
      `).join('');
    }

    function renderInbox() {
      const q = $('inboxFilter').value.trim().toLowerCase();
      const rows = state.inbox.filter((item) => {
        if (!q) return true;
        return item.sender.toLowerCase().includes(q) || item.body_text.toLowerCase().includes(q);
      });
      $('inboxList').innerHTML = rows.length ? rows.map((item) => `
        <div class="item">
          <h3>${item.body_preview || '(empty)'}</h3>
          <div class="meta">${item.sender} · ${item.ts}</div>
          <div class="snippet">${item.body_text}</div>
          <details style="margin-top:6px;"><summary>Route / provenance</summary>
            <div class="tiny" style="white-space: pre-wrap; margin-top:6px;">${(item.forwards || []).map(f => `${f.destination} (${f.reason})`).join('\n') || 'No forward metadata.'}</div>
          </details>
        </div>
      `).join('') : '<div class="tiny">No inbox messages.</div>';
    }

    function parsePeerPoliciesFor(destination) {
      const dest = (destination || '').trim();
      if (!dest) return false;
      const found = state.peers.find((p) => p.address === dest);
      return Boolean(found?.alwaysSign);
    }

    async function fileToBase64(file) {
      const buf = await file.arrayBuffer();
      let binary = '';
      const bytes = new Uint8Array(buf);
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        const slice = bytes.subarray(i, i + chunk);
        binary += String.fromCharCode(...slice);
      }
      return btoa(binary);
    }

    async function collectAttachments() {
      const files = Array.from($('attachments').files || []);
      const mapped = [];
      for (const file of files) {
        mapped.push({
          name: file.name,
          mime: file.type || 'application/octet-stream',
          data_base64: await fileToBase64(file),
        });
      }
      state.attachments = mapped;
      $('attachMeta').textContent = files.length ? `${files.length} file(s) selected` : 'No files selected';
      return mapped;
    }

    async function runPost() {
      const body = $('mainBox').value.trim();
      if (!body) {
        setHomeStatus('Message body is required.', 'error');
        return;
      }
      const destination = $('destination').value.trim();
      const sign = $('sign').checked || parsePeerPoliciesFor(destination);
      const payload = {
        destination: destination || null,
        extra_destinations: parseCsv($('extraDest').value),
        body_text: body,
        sign,
        identity: state.selectedIdentity || null,
        sources: parseSources($('sources').value),
        attachments: await collectAttachments(),
      };

      $('postBtn').disabled = true;
      try {
        const data = await api('/api/compose', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        state.lastCompose = data;
        state.lastSearch = null;
        state.messageHistory.push({
          kind: 'outbound',
          sender: state.selectedIdentity || state.localAddress,
          body,
          ts: new Date().toISOString(),
          route: (data.local_event?.forwards || []).map(f => `${f.destination} (${f.reason})`).join('\n') || 'No route metadata.',
        });
        for (const match of (data.returned_matches || [])) {
          state.messageHistory.push({
            kind: 'inbound',
            sender: match.sender,
            body: match.body_text || match.body_preview || '',
            ts: new Date().toISOString(),
            route: 'Matched message returned from local routing cache.',
          });
        }
        saveState();
        setHomeStatus(`Posted. Received ${data.returned_matches?.length || 0} related message(s).`);
        renderResults();
        renderThread();
        setActiveView('results');
      } catch (err) {
        setHomeStatus(String(err), 'error');
      } finally {
        $('postBtn').disabled = false;
      }
    }

    async function runSearch() {
      const q = $('mainBox').value.trim();
      if (!q) {
        setHomeStatus('Enter text to search pool.', 'error');
        return;
      }
      $('searchBtn').disabled = true;
      try {
        const data = await api(`/api/cache?q=${encodeURIComponent(q)}&limit=80`);
        state.lastSearch = data;
        state.lastCompose = null;
        setHomeStatus(`Search returned ${data.entries?.length || 0} matching pool entries.`);
        renderResults();
        setActiveView('results');
      } catch (err) {
        setHomeStatus(String(err), 'error');
      } finally {
        $('searchBtn').disabled = false;
      }
    }

    async function refreshInbox() {
      try {
        const data = await api('/api/inbox?limit=200');
        state.inbox = data.entries || [];
        renderInbox();
      } catch (err) {
        $('inboxList').innerHTML = `<div class="status bad">${String(err)}</div>`;
      }
    }

    function setActiveView(viewName) {
      for (const tab of document.querySelectorAll('.tab')) {
        tab.classList.toggle('active', tab.dataset.view === viewName);
      }
      for (const view of document.querySelectorAll('.view')) {
        view.classList.toggle('active', view.id === `view-${viewName}`);
      }
      if (viewName === 'inbox') {
        refreshInbox();
      }
      if (viewName === 'thread') {
        renderThread();
      }
    }

    function wireIdentityActions() {
      $('identityTable').addEventListener('click', (ev) => {
        const btn = ev.target.closest('button');
        if (!btn) return;
        const action = btn.dataset.act;
        const id = decodeURIComponent(btn.dataset.id || '');
        if (action === 'use-id') {
          state.selectedIdentity = id;
          renderIdentitySelect();
          renderIdentityTable();
        }
        if (action === 'del-id') {
          state.identities = state.identities.filter((x) => x !== id);
          if (state.selectedIdentity === id) state.selectedIdentity = state.localAddress || '';
          renderIdentitySelect();
          renderIdentityTable();
          saveState();
        }
      });

      $('peerTable').addEventListener('click', (ev) => {
        const btn = ev.target.closest('button');
        if (!btn) return;
        const action = btn.dataset.act;
        const peer = decodeURIComponent(btn.dataset.peer || '');
        if (action === 'del-peer') {
          state.peers = state.peers.filter((x) => x.address !== peer);
          renderPeerTable();
          saveState();
        }
      });

      $('peerTable').addEventListener('change', (ev) => {
        const box = ev.target.closest('input[type="checkbox"]');
        if (!box || box.dataset.act !== 'toggle-peer') return;
        const peer = decodeURIComponent(box.dataset.peer || '');
        const row = state.peers.find((x) => x.address === peer);
        if (row) {
          row.alwaysSign = box.checked;
          saveState();
        }
      });
    }

    async function bootstrap() {
      loadState();
      try {
        const boot = await api('/api/bootstrap');
        state.localAddress = boot.local_address || '';
        renderRuntimePills(boot);
        if (!state.selectedIdentity) state.selectedIdentity = state.localAddress;
      } catch (err) {
        $('runtimeStatus').innerHTML = `<span class="status bad">${String(err)}</span>`;
      }
      renderIdentitySelect();
      renderIdentityTable();
      renderPeerTable();
      renderResults();
      renderThread();
      renderInbox();
      saveState();
    }

    document.querySelectorAll('.tab').forEach((tab) => {
      tab.addEventListener('click', () => setActiveView(tab.dataset.view));
    });
    $('identitySelect').addEventListener('change', () => {
      state.selectedIdentity = $('identitySelect').value;
      saveState();
      renderIdentityTable();
    });

    $('attachments').addEventListener('change', collectAttachments);
    $('postBtn').addEventListener('click', runPost);
    $('searchBtn').addEventListener('click', runSearch);
    $('refreshInbox').addEventListener('click', refreshInbox);
    $('inboxFilter').addEventListener('input', renderInbox);

    $('threadReplyBtn').addEventListener('click', () => {
      const body = $('threadReply').value.trim();
      if (!body) return;
      $('mainBox').value = body;
      $('threadReply').value = '';
      setActiveView('home');
      runPost();
    });

    $('addIdentity').addEventListener('click', () => {
      const value = $('newIdentity').value.trim();
      if (!value) return;
      if (!state.identities.includes(value) && value !== state.localAddress) {
        state.identities.push(value);
      }
      state.selectedIdentity = value;
      $('newIdentity').value = '';
      renderIdentitySelect();
      renderIdentityTable();
      saveState();
    });

    $('addPeer').addEventListener('click', () => {
      const value = $('newPeer').value.trim();
      if (!value) return;
      if (!state.peers.find((p) => p.address === value)) {
        state.peers.push({ address: value, alwaysSign: false });
      }
      $('newPeer').value = '';
      renderPeerTable();
      saveState();
    });

    wireIdentityActions();
    bootstrap();
  </script>
</body>
</html>
